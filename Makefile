# iac.tender.pro backend Makefile
SHELL    = /bin/bash
CFG     ?= .config
PGM_CMD ?= $(SHELL) pgm/pgm.sh

# container prefix
# see project in fidm.yml
PROJECT ?= test

# docker images для "make deps"
CONSUP_IMAGES = consul postgres pgrest

# Полный путь к текущему каталогу
APP_ROOT ?= $(shell dirname $$PWD)

# Имя текущего каталога
APP_PATH ?= $(shell basename $$PWD)

# имя сайта для контейнера
APP_SITE ?= test.dev.lan

# имя БД
DB_NAME  ?= test01

# Шаблон создания БД
#DB_TEMPLATE ?= tpro-template

PG_CONTAINER ?= consup_postgres_common

all: start

## Цели:

# проверка наличия файла .config
chk_cfg:
	@[ -f $(CFG) ] || { echo "Error: no file $(CFG)" && exit 1 ; }

# шаблон файла .config
define CONFIG_DEF
# pgm config file, generated by make $(CFG)

# Project name
PROJECT=$(PROJECT)

# Database name
DB_NAME=$(DB_NAME)

# Container name
APP_SITE=$(APP_SITE)

# Database template name
DB_TEMPLATE=$(DB_TEMPLATE)

# pgm creatif
DO_CREATIF="tnd"

# pgm recreate
DO_RECREATE="tnd"

CONSUP_ROOT=/opt/consup
endef
export CONFIG_DEF

## настройка контейнера из CI хука
setup: $(CFG)

## старт контейнера из CI хука
start-hook: startonly

## стартовать контейнер pgrest, предварительно удалив старый, если был
start: vars stop startonly

## остановить и удалить контейнер
stop: $(CFG)
	@echo "*** $@ ***"
	@source $(CFG) && \
  fidm rm mode=www name=$$APP_SITE args_add=--env=DB_NAME=$$DB_NAME

## остановить и удалить контейнер и все контейнеры, от которых он зависит
stopall: $(CFG)
	@echo "*** $@ ***"
	@source $(CFG) && \
  fidm rm -a mode=www name=$$APP_SITE args_add=--env=DB_NAME=$$DB_NAME

## стартовать контейнер pgrest, ничего не удаляя
startonly: vars
	@echo "*** $@ ***"
	@source $(CFG) && \
  fidm start mode=www name=$$APP_SITE \
    args_add=--env=DB_NAME=$$DB_NAME \
    args_add=--volume=$(APP_ROOT)/$(APP_PATH):/home/app \
    args_add=--volume=$(APP_ROOT)/log/$(APP_PATH):/var/log/supervisor

## проверить, что запущен контейнер postgresql
chk_pg:
	@RUNNING=$$(docker inspect --format="{{ .State.Running }}" $(PG_CONTAINER) 2> /dev/null) ; \
[ "$$RUNNING" == "true" ] || { echo "Error: container $(PG_CONTAINER) must be started" ; exit 1 ; }

## сборка пакетов БД (код .ondbready выполняется при старте контейнера pgrest)
build: $(CFG)
	@echo "*** $@ ***"
	source $(CFG) && \
docker exec -i "$$PROJECT_$${APP_SITE}_www" bash .ondbready

## сборка пакетов БД, версия для обновленного fidm (TODO)
build-new:
	@source $(CFG) && \
FIDM_CMD="bash .ondbready" fidm exec fidm.yml mode=www name=$$APP_SITE

# *****************************************************************************
# Дополнительные цели
# *****************************************************************************

# удаление БД через контейнер postgresql
dropdb: stop chk_pg
	@source $(CFG) && \
echo "drop database $$DB_NAME" | docker exec -i $(PG_CONTAINER) gosu postgres psql template1

# обновить субмодули чтобы их можно было редактировать
# аналог git clone --recursive
git-upd:
	@echo "*** $@ ***"
	@for d in www pgm ; do pushd $$d ; git checkout ; popd ;  done

# запуск psql в контейнере
psql: startonly
	@echo "*** $@ ***"
	source $(CFG) && \
docker exec -ti "$${PROJECT}_$${APP_SITE}_www" make $@-inside

# эта команда выполняется из контейнера
psql-inside:
	PGPASSWORD=$${DB_PASS} TERM=xterm psql -U $${DB_NAME} -h $${PG_HOST} -d $${DB_NAME}

# запуск psql в контейнере
update: startonly
	@echo "*** $@ ***"
	source $(CFG) && \
docker exec -t "$${PROJECT}_$${APP_SITE}_www" make update-inside

update-inside:
	source $(CFG) && \
  bash /home/app/pgm/pgm-inside-docker.sh /home/app recreate $$DO_RECREATE >> /var/log/supervisor/update.log && \
  supervisorctl -c /etc/supervisor/supervisord.conf restart dbrpc >> /var/log/supervisor/update.log

# запуск bash в контейнере
bash: startonly
	@echo "*** $@ ***"
	source $(CFG) && \
docker exec -ti "$${PROJECT}_$${APP_SITE}_www" bash

# дамп схемы exp
dump-exp:
	@echo "*** $@ ***"
	source $(CFG) && \
docker exec -ti "$${PROJECT}_$${APP_SITE}_www" make $@-inside

# эта команда выполняется из контейнера
dump-exp-inside:
	echo "=$DB_NAME="
	PGPASSWORD=$$DB_PASS pg_dump -n exp -F t -O -h $$PG_HOST -U $$DB_NAME $$DB_NAME | gzip > pgdump.tar.gz

# *****************************************************************************

clean:
	@echo "*** $@ ***"
	[ ! -f $(CFG) ] || rm $(CFG)

vars: $(CFG)

$(CFG):
	@echo "*** $@ ***"
	@[ -f $@ ] || { echo "$$CONFIG_DEF" > $@ ; echo "Warning: Created default $@" ; }

# актуальная версия - см http://git.it.tender.pro/iac/pg-skel/src/master/Makefile#L62
deps:
	@echo "*** $@ ***"
	# code from http://docs.docker.com/linux/step_one/
	which docker > /dev/null || wget -qO- https://get.docker.com/ | sh
	# code from https://github.com/LeKovr/fidm
	which fidm > /dev/null || wget -qO- https://raw.githubusercontent.com/LeKovr/fidm/master/install.sh | sh
	# Каталог **consup** должен быть доступен из каталога **iac** как `../consup` или `../../consup`.
	[[ "$CONSUP_ROOT" ]] || cd .. && wget -qO- https://raw.githubusercontent.com/LeKovr/consup/master/install.sh | sh
	# контейнеры Docker
	for n in $(CONSUP_IMAGES) ; do docker pull lekovr/consup_$$n ; done
	@echo Done

help:
	@grep -A 1 "^##" Makefile | less

##
## Press 'q' for exit
##

.PHONY: all build deps
